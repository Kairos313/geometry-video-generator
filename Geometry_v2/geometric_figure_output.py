# base_diagram.py
# This script defines static Manim VGroups for the geometric figures described in the problem.
# Generated by Manim Cinematic Surveyor.

from manim import *
import numpy as np

def create_base_diagram_main(solution: dict) -> VGroup:
    """
    Creates the main pentagon figure by rigorously computing coordinates
    based on the provided solution and geometric principles.
    """
    
    # 1. Extract data from solution and establish scale
    scale_factor = 0.25
    ad_len = 12 * scale_factor  # AD = 12 cm
    de_len = 9 * scale_factor   # DE = 9 cm
    bc_len = 12 * scale_factor  # BC = AD (given)
    
    # From solution: AE = 15 cm, BE = 15 cm, BD = 24 cm, AC = 24 cm, CE = 9 cm
    ae_len = 15 * scale_factor
    be_len = 15 * scale_factor
    bd_len = 24 * scale_factor
    ac_len = 24 * scale_factor
    ce_len = 9 * scale_factor
    
    # 2. Establish orientation and anchors to match the image
    # From the image, A is at bottom-left, B is at bottom-right
    coord_A = np.array([-4.0, -1.5, 0])
    coord_B = np.array([4.0, -1.5, 0])
    
    # 3. Computationally construct remaining points
    # Find D: D is positioned such that angle ADB = 90° and AD = 12
    # Since angle ADB = 90°, D lies on a circle with diameter AB
    # Also, D is at distance AD from A
    
    # // NUMPY-DOCS: numpy.linalg.norm
    ab_len = np.linalg.norm(coord_B - coord_A)
    mid_AB = (coord_A + coord_B) / 2
    radius_ab_circle = ab_len / 2
    
    # Solve intersection of two circles:
    # Circle 1: Center A, radius ad_len
    # Circle 2: Center mid_AB, radius radius_ab_circle
    d = np.linalg.norm(mid_AB - coord_A)
    a = (ad_len**2 - radius_ab_circle**2 + d**2) / (2 * d)
    h = np.sqrt(ad_len**2 - a**2)
    p2 = coord_A + a * (mid_AB - coord_A) / d
    
    # Choose the intersection with positive y-value (D is above AB in the image)
    coord_D = np.array([p2[0] - h*(mid_AB[1]-coord_A[1])/d, p2[1] + h*(mid_AB[0]-coord_A[0])/d, 0])
    
    # Find C: Since angle ACB = 90° and BC = AD, C lies on circle with diameter AB
    # and at distance BC from B
    # Using similar intersection logic
    a_c = (bc_len**2 - radius_ab_circle**2 + d**2) / (2 * d)
    h_c = np.sqrt(bc_len**2 - a_c**2)
    p2_c = coord_B + a_c * (mid_AB - coord_B) / d
    
    # Choose the intersection with positive y-value (C is above AB in the image)
    coord_C = np.array([p2_c[0] + h_c*(mid_AB[1]-coord_B[1])/d, p2_c[1] - h_c*(mid_AB[0]-coord_B[0])/d, 0])
    
    # Find E: Intersection of lines AC and BD
    # // DOCS: manim.utils.geometry.line_intersection
    coord_E = line_intersection((coord_A, coord_C), (coord_B, coord_D))
    
    # 4. Create Manim mobjects with explicit positioning
    
    # Create lines for the pentagon
    # // DOCS: manim.mobject.geometry.line.Line
    line_AB = Line(coord_A, coord_B, color="#FFFFFF", stroke_width=2)
    line_BC = Line(coord_B, coord_C, color="#FFFFFF", stroke_width=2)
    line_CD = Line(coord_C, coord_D, color="#FFFFFF", stroke_width=2)
    line_DA = Line(coord_D, coord_A, color="#FFFFFF", stroke_width=2)
    line_AC = Line(coord_A, coord_C, color="#FFFFFF", stroke_width=2)
    line_BD = Line(coord_B, coord_D, color="#FFFFFF", stroke_width=2)
    
    # Create vertex labels with explicit positioning
    # // DOCS: manim.mobject.text.tex_mobject.MathTex
    label_A = MathTex("A", color="#FFFFFF", font_size=32).move_to(coord_A + np.array([-0.3, -0.3, 0]))
    label_B = MathTex("B", color="#FFFFFF", font_size=32).move_to(coord_B + np.array([0.3, -0.3, 0]))
    label_C = MathTex("C", color="#FFFFFF", font_size=32).move_to(coord_C + np.array([0.3, 0.3, 0]))
    label_D = MathTex("D", color="#FFFFFF", font_size=32).move_to(coord_D + np.array([-0.3, 0.3, 0]))
    label_E = MathTex("E", color="#FFFFFF", font_size=32).move_to(coord_E + np.array([0.0, 0.3, 0]))
    
    # Create length labels with explicit positioning
    # Label for AD = 12
    mid_AD = (coord_A + coord_D) / 2
    label_AD = MathTex("12", color="#22C55E", font_size=24).move_to(mid_AD + np.array([-0.4, 0.0, 0]))
    
    # Label for DE = 9
    mid_DE = (coord_D + coord_E) / 2
    label_DE = MathTex("9", color="#22C55E", font_size=24).move_to(mid_DE + np.array([0.0, 0.4, 0]))
    
    # Label for AE = 15
    mid_AE = (coord_A + coord_E) / 2
    label_AE = MathTex("15", color="#22C55E", font_size=24).move_to(mid_AE + np.array([-0.3, 0.0, 0]))
    
    # Create right angle markers with correct orientation
    # Right angle at C (angle ACB)
    # // DOCS: manim.mobject.geometry.angle.RightAngle
    vec_CA = coord_A - coord_C
    vec_CB = coord_B - coord_C
    # // NUMPY-DOCS: numpy.cross
    z_cross_acb = np.cross(vec_CA, vec_CB)[2]
    right_angle_C = RightAngle(Line(coord_C, coord_A), Line(coord_C, coord_B), 
                              length=0.3, other_angle=(z_cross_acb < 0), color="#FDE047")
    
    # Right angle at D (angle ADB)
    vec_DA = coord_A - coord_D
    vec_DB = coord_B - coord_D
    z_cross_adb = np.cross(vec_DA, vec_DB)[2]
    right_angle_D = RightAngle(Line(coord_D, coord_A), Line(coord_D, coord_B), 
                              length=0.3, other_angle=(z_cross_adb < 0), color="#FDE047")
    
    # Create vertex dots
    # // DOCS: manim.mobject.geometry.arc.Dot
    dot_A = Dot(coord_A, radius=0.08, color="#FFFFFF")
    dot_B = Dot(coord_B, radius=0.08, color="#FFFFFF")
    dot_C = Dot(coord_C, radius=0.08, color="#FFFFFF")
    dot_D = Dot(coord_D, radius=0.08, color="#FFFFFF")
    dot_E = Dot(coord_E, radius=0.08, color="#FFFFFF")
    
    # // DOCS: manim.mobject.container.VGroup
    return VGroup(
        line_AB, line_BC, line_CD, line_DA, line_AC, line_BD,
        dot_A, dot_B, dot_C, dot_D, dot_E,
        label_A, label_B, label_C, label_D, label_E,
        label_AD, label_DE, label_AE,
        right_angle_C, right_angle_D
    )

def create_base_diagram_triangles(solution: dict) -> VGroup:
    """
    Creates highlighted triangles for the congruence proof visualization.
    """
    
    # Use same coordinate calculation as main diagram
    scale_factor = 0.25
    ad_len = 12 * scale_factor
    bc_len = 12 * scale_factor
    
    coord_A = np.array([-4.0, -1.5, 0])
    coord_B = np.array([4.0, -1.5, 0])
    
    # Recalculate D and C coordinates
    ab_len = np.linalg.norm(coord_B - coord_A)
    mid_AB = (coord_A + coord_B) / 2
    radius_ab_circle = ab_len / 2
    
    d = np.linalg.norm(mid_AB - coord_A)
    a = (ad_len**2 - radius_ab_circle**2 + d**2) / (2 * d)
    h = np.sqrt(ad_len**2 - a**2)
    p2 = coord_A + a * (mid_AB - coord_A) / d
    coord_D = np.array([p2[0] - h*(mid_AB[1]-coord_A[1])/d, p2[1] + h*(mid_AB[0]-coord_A[0])/d, 0])
    
    a_c = (bc_len**2 - radius_ab_circle**2 + d**2) / (2 * d)
    h_c = np.sqrt(bc_len**2 - a_c**2)
    p2_c = coord_B + a_c * (mid_AB - coord_B) / d
    coord_C = np.array([p2_c[0] + h_c*(mid_AB[1]-coord_B[1])/d, p2_c[1] - h_c*(mid_AB[0]-coord_B[0])/d, 0])
    
    # Create highlighted triangles
    # // DOCS: manim.mobject.geometry.polygram.Polygon
    triangle_ABC = Polygon(coord_A, coord_B, coord_C, 
                          fill_color="#3B82F6", fill_opacity=0.3, 
                          stroke_color="#3B82F6", stroke_width=3)
    
    triangle_BAD = Polygon(coord_B, coord_A, coord_D, 
                          fill_color="#22C55E", fill_opacity=0.3, 
                          stroke_color="#22C55E", stroke_width=3)
    
    # // DOCS: manim.mobject.container.VGroup
    return VGroup(triangle_ABC, triangle_BAD)